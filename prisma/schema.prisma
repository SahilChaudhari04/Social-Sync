generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  userId    String   @id @default(uuid())
  email     String   @unique
  firstName String?
  lastName  String?
  username  String   @unique
  password  String
  salt      String
  dob       DateTime
  createdAt DateTime @default(now())
  Stream    Stream[]
  Vote      Vote[]
  Comment Comment[]
  CommentVote CommentVote[]
  StreamPayment StreamPayment[]
  StreamExit StreamExit[]
  UserSubscriptions Subscriptions[] @relation("UserSubscriptions")
  CreatorSubscriptions Subscriptions[] @relation("CreatorSubscriptions")
}

model Stream {
  streamId       String   @id @default(uuid())
  thumbnailUrl   String
  startTimestamp DateTime
  endTimestamp   DateTime
  storageUrl     String
  title          String
  description    String?
  createdAt      DateTime @default(now())
  userUserId     String
  tags           String[]
  creator        User     @relation(fields: [userUserId], references: [userId])
  Vote           Vote[]
  Comment       Comment[]
  StreamPayment StreamPayment[]
  StreamExit     StreamExit[]
  Subscriptions  Subscriptions[]
}

model Vote {
  createdAt      DateTime @default(now())
  videoTimestamp DateTime
  streamStreamId String
  userUserId     String
  dislike        Boolean
  stream         Stream   @relation(fields: [streamStreamId], references: [streamId])
  user           User     @relation(fields: [userUserId], references: [userId])

  @@id([streamStreamId, userUserId])
}

model Comment {
  commentId      String        @id @default(uuid())
  stream         Stream        @relation(fields: [streamStreamId], references: [streamId])
  user           User          @relation(fields: [userUserId], references: [userId])
  content        String
  createdAt      DateTime      @default(now())
  videoTimestamp DateTime
  streamStreamId String
  userUserId     String
  CommentVote    CommentVote[]
}

model CommentVote {
  comment          Comment  @relation(fields: [commentCommentId], references: [commentId])
  user             User     @relation(fields: [userUserId], references: [userId])
  dislike          Boolean
  createdAt        DateTime @default(now())
  commentCommentId String
  userUserId       String

  @@id([commentCommentId, userUserId])
}

model StreamPayment {
  paymentId      String   @id @default(uuid())
  amount         Int
  user           User     @relation(fields: [userUserId], references: [userId])
  stream         Stream   @relation(fields: [streamStreamId], references: [streamId])
  createdAt      DateTime @default(now())
  userUserId     String
  streamStreamId String
}

model StreamExit {
  streamExitId   String   @id @default(uuid())
  stream         Stream   @relation(fields: [streamStreamId], references: [streamId])
  user           User     @relation(fields: [userUserId], references: [userId])
  videoTimestamp DateTime
  createdAt      DateTime
  streamStreamId String
  userUserId     String
}

model Subscriptions {
  user           User     @relation(fields: [userUserId], references: [userId], name: "UserSubscriptions")
  createdAt      DateTime @default(now())
  stream         Stream?  @relation(fields: [streamStreamId], references: [streamId]) //only if a user subscribes a creator while watching any of his streams
  userUserId     String
  streamStreamId String?
  creator        User     @relation(fields: [creatorUserId], references: [userId], name: "CreatorSubscriptions")
  creatorUserId  String
  @@id([userUserId,creatorUserId])
}
